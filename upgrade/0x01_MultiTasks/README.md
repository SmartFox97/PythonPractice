# 一、Python 多任务编程 2020.08.06

# 0x00：前言

### 一、什么是多任务

+ 概念

  > 多任务处理是指用户可以在同一时间内运行多个应用程序，即同一时间，多个任务同时执行。

### 二、多任务的执行方式

+ 并发

  > 并发是指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
  >
  > 通俗来讲，就是指两个或多个事件在同一时间间隔发生，即多个任务**交替**执行。

  ![并发](https://oss.smartfox.cc/2020/08/07/ab1f76c755184.png)

+ 并行

  > 并行是指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。
  
  ![并行](https://oss.smartfox.cc/2020/08/07/77991d4c9abd0.png)

-----

# 0x01：进程

### 一、什么是进程

+ 概念

  进程是指计算机中已运行的程序；在**面向进程**设计的系统（早期的UNIX和Linux2.4及更早的版本）中，进程是程序的执行实体；在**面向线程**设计的系统（现阶段大部分系统和Linux2.6及往后最新版本）中，进程不再是基本运行单位，而是承载**线程**的容器。

  简单来讲，现阶段的操作系统中，进程是系统进行资源分配的基本单位；一个运行的程序至少会创建一个进程，而一个进程中至少包含一个线程。

+ 作用

  使用多进程实现多任务

### 二、多进程

+ 多进程

  > 多进程即为一个程序通过创建多个进程以达到完成多任务的方式。

  ![多进程](https://oss.smartfox.cc/2020/08/07/d45647637f25b.png)

  + 多进程可以完成多任务，每个进程就好比一家独立的公司，每个公司都各自在运营，每个进程也各自在运行，执行各自的任务。

+ 多进程的使用

  + 导入模块

  ```python
  import multiprocessing
  ```

  + 创建子进程对象

  ```python
  p1 = multiprocessing.Process(target=sing)
  p2 = multiprocessing.Process(target=dance)
  ```

  + 启动子进程

  ```python
  p1.start()
  p2.start()
  ```

+ 获取进程编号

  + 获取进程的对象

  ```python
  multiprocessing.current_process()
  ```

  + 获取进程的编号

  ```python
  os.getpid()
  ```

  + 获取父进程的编号

  ```python
  os.getppid()
  ```

  + 结束进程

  ```python
  os.kill('程序PID','执行信号')
  ```

  > `os.kill`只能用于UNIX平台上，这里的执行信号是UNIX系统中kill指令的所需的信号，如下图所示
  >
  > ![kill指令信号](https://oss.smartfox.cc/2020/08/07/1705253d7ef0d.png)
  >
  > 其中常用的有
  >
  > | 信号编号 | 信号名称 | 信号含义               |
  > | -------- | -------- | ---------------------- |
  > | 1        | SIGHUP   | 挂起信号               |
  > | 2        | SIGINT   | 中断信号（同Ctrl + C） |
  > | 3        | SIGQUIT  | 退出信号（同Ctrl + \） |
  > | 9        | SIGKILL  | 杀死信号               |
  > | 11       | SIGSEGV  | 段错误信号             |
  > | 15       | SIGTERM  | 终止信号（默认）       |
  > | 18       | SIGCONT  | 继续运行信号           |
  > | 19       | SIGSTOP  | 暂停信号（同Ctrl + Z） |

+ 进程执行带有参数的任务

  + 以元组方式传参`args`

  ```python
  import multiprocessing
  
  def task(count):
      print('复读鸡获得了任务，复读', count, ’次‘)
      for i in range(count):
          print("我是复读鸡！")
      else:
          print("任务执行完成")
  
  if __name__ == '__main__':
      # 创建子进程
      # args: 以元组的方式给任务传入参数
      sub_process = multiprocessing.Process(target=task, args=(5,))
      sub_process.start()
  ```

  + 以字典方式传参`kwargs`

  ```python
  import multiprocessing
  
  def task(count):
      print('复读鸡获得了任务，复读', count, ’次‘)
      for i in range(count):
          print("我是复读鸡！")
      else:
          print("任务执行完成")
  
  if __name__ == '__main__':
      # 创建子进程
      # kwargs: 表示以字典方式传入参数
      sub_process = multiprocessing.Process(target=task, kwargs={"count": 3})
      sub_process.start()
  ```

+ 多进程的注意点

  + 进程之间不共享全局变量

    + 创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本

    TODO

  + 主进程会等待所有的子进程执行结束再结束

  + 主进程结束时同时销毁所有子进程

    + 守护主进程
      + 守护主进程就是主进程退出子进程销毁不再执行

    ```python
    子进程对象.daemon = True
    ```

    + 销毁子进程
      + 子进程执行结束

    ```python
    子进程对象.terminate()
    ```



----------

# 0x02：线程

### 一、什么是线程

+ 线程的介绍
+ 线程的概念
+ 线程的作用
+ 注意点
  + 多线程的执行是无序的
  + 主线程会等待所有子线程执行完成后才退出

### 二、多线程

+ 多线程的使用
+ 线程执行带参的任务
+ 资源竞争问题



-----

# 0x03：锁

### 一、什么是锁



### 二、互斥锁

+ 互斥锁的概念

  + 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。
  + 互斥锁是**多个线程一起去抢**，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。

+ 互斥锁的使用

  + 创建锁 `mutex = threading.Lock()`

  + 上锁 `mutex.acquire()`
  + 释放锁`mutex.release()`
  + 注意点
    + **acquire和release方法之间的代码同一时刻只能有一个线程去操作**
    + **如果在调用acquire方法的时候 其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。**

+ 死锁

--------

# 0x04：进程和线程的对比

### 一、关系对比

### 二、区别对比

+ 全局变量
  + 进程不共享全局变量
  + 线程可以共享全局变量，出现资源竞争问题，可以通过互斥锁和线程同步来解决
+ 开销上
  + 创建进程的开销比创建线程的开销大
+ 概念上
  + 进程是操作系统资源分配的单位
  + 线程是CPU调度的单位
+ 关系上
  + 线程依附进程存在，不能单独存在
+ 稳定性上
  + 多进程编程比单进程多线程稳定性更好

### 三、优缺点对比

+ 进程
  + **优点：**稳定性高、可以使用多核
  + **缺点：**开销大
+ 线程
  + **优点：**开销小
  + **缺点：**不能使用多核

